#include <time.h>
#include <math.h>


/*************************************************************/
/* Solar position calculation functions */
/*************************************************************/

double calcTimeJulianCent(double jd) {
	double T = (jd - 2451545.0)/36525.0;
	return T;
}

double calcJDFromJulianCent(double t) {
	double JD = t * 36525.0 + 2451545.0;
	return JD;
}

bool isLeapYear(int yr) {
	return ((yr % 4 == 0 && yr % 100 != 0) || yr % 400 == 0);
}

struct ymd{
	int year;
	int month;
	double day;
};

ymd calcDateFromJD(double jd) {
	double z = floor(jd + 0.5);
	double f = (jd + 0.5) - z;
	double A, alpha;
	if (z < 2299161) {
		A = z;
	} else {
		alpha = floor((z - 1867216.25)/36524.25);
		A = z + 1 + alpha - floor(alpha/4);
	}
	int B = A + 1524;
	int C = floor((B - 122.1)/365.25);
	int D = floor(365.25 * C);
	int E = floor((B - D)/30.6001);
	double day = B - D - floor(30.6001 * E) + f;
	int month = (E < 14) ? E - 1 : E - 13;
	int year = (month > 2) ? C - 4716 : C - 4715;

	return ymd{ year,  month,  day};
}

double calcDoyFromJD(double jd) {
	ymd date = calcDateFromJD(jd);

	int k = (isLeapYear(date.year) ? 1 : 2);
	double doy = floor((275 * date.month)/9) - k * floor((date.month + 9)/12) + date.day -30;

	return doy;
}


double radToDeg(double angleRad) {
	return (180.0 * angleRad / M_PI);
}

double degToRad(double angleDeg) {
	return (M_PI * angleDeg / 180.0);
}

double calcGeomMeanLongSun(t) {
	double L0 = 280.46646 + t * (36000.76983 + t*(0.0003032));
	while(L0 > 360.0) {
		L0 -= 360.0;
	}
	while(L0 < 0.0) {
		L0 += 360.0;
	}
	return L0;		// in degrees
}

double calcGeomMeanAnomalySun(double t) {
	double M = 357.52911 + t * (35999.05029 - 0.0001537 * t);
	return M;		// in degrees
}

double calcEccentricityEarthOrbit(double t) {
	double e = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);
	return e;		// unitless
}

double calcSunEqOfCenter(double t) {
	double m = calcGeomMeanAnomalySun(t);
	double mrad = degToRad(m);
	double sinm = sin(mrad);
	double sin2m = sin(mrad+mrad);
	double sin3m = sin(mrad+mrad+mrad);
	double C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;
	return C;		// in degrees
}

double calcSunTrueLong(double t) {
	double l0 = calcGeomMeanLongSun(t);
	double c = calcSunEqOfCenter(t);
	double O = l0 + c;
	return O;		// in degrees
}

double calcSunTrueAnomaly(double t) {
	double m = calcGeomMeanAnomalySun(t);
	double c = calcSunEqOfCenter(t);
	double v = m + c;
	return v;		// in degrees
}

double calcSunRadVector(double t) {
	double v = calcSunTrueAnomaly(t);
	double e = calcEccentricityEarthOrbit(t);
	double R = (1.000001018 * (1 - e * e)) / (1 + e * cos(degToRad(v)));
	return R;		// in AUs
}

double calcSunApparentLong(double t) {
	double o = calcSunTrueLong(t);
	double omega = 125.04 - 1934.136 * t;
	double lambda = o - 0.00569 - 0.00478 * sin(degToRad(omega));
	return lambda;		// in degrees
}

double calcMeanObliquityOfEcliptic(double t) {
	double seconds = 21.448 - t*(46.8150 + t*(0.00059 - t*(0.001813)));
	double e0 = 23.0 + (26.0 + (seconds/60.0))/60.0;
	return e0;		// in degrees
}

double calcObliquityCorrection(double t) {
	double e0 = calcMeanObliquityOfEcliptic(t);
	double omega = 125.04 - 1934.136 * t;
	double e = e0 + 0.00256 * cos(degToRad(omega));
	return e;		// in degrees
}

double calcSunRtAscension(double t) {
	double e = calcObliquityCorrection(t);
	double lambda = calcSunApparentLong(t);
	double tananum = (cos(degToRad(e)) * Math.sin(degToRad(lambda)));
	double tanadenom = (cos(degToRad(lambda)));
	double alpha = radToDeg(atan2(tananum, tanadenom));
	return alpha;		// in degrees
}

double calcSunDeclination(t) {
	double e = calcObliquityCorrection(t);
	double lambda = calcSunApparentLong(t);
	double sint = sin(degToRad(e)) * sin(degToRad(lambda));
	double theta = radToDeg(asin(sint));
	return theta;		// in degrees
}

double calcEquationOfTime(double t) {
	double epsilon = calcObliquityCorrection(t);
	double l0 = calcGeomMeanLongSun(t);
	double e = calcEccentricityEarthOrbit(t);
	double m = calcGeomMeanAnomalySun(t);

	double y = tan(degToRad(epsilon)/2.0);
	y *= y;

	double sin2l0 = sin(2.0 * degToRad(l0));
	double sinm   = sin(degToRad(m));
	double cos2l0 = cos(2.0 * degToRad(l0));
	double sin4l0 = sin(4.0 * degToRad(l0));
	double sin2m  = sin(2.0 * degToRad(m));

	double Etime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;
	return radToDeg(Etime)*4.0;	// in minutes of time
}

double calcHourAngleSunrise(double lat, double solarDec) {
	double latRad = degToRad(lat);
	double sdRad  = degToRad(solarDec);
	double HAarg = (cos(degToRad(90.833))/(cos(latRad)*cos(sdRad))-tan(latRad) * tan(sdRad));
	double HA = acos(HAarg);
	return HA;		// in radians (for sunset, use -HA)
}

double getJD(int year, int month, double day) {
	if (month <= 2) {
		year -= 1;
		month += 12;
	}
	int A = floor(year/100);
	int B = 2 - A + floor(A/4);
	double JD = floor(365.25*(year + 4716)) + Math.floor(30.6001*(month+1)) + day + B - 1524.5;
	return JD;
}

double calcRefraction(double elev) {
	double correction;
	if (elev > 85.0) {
		correction = 0.0;
	} else {
		double te = tan(degToRad(elev));
		if (elev > 5.0) {
			correction = 58.1 / te - 0.07 / (te*te*te) + 0.000086 / (te*te*te*te*te);
		} else if (elev > -0.575) {
			correction = 1735.0 + elev * (-518.2 + elev * (103.4 + elev * (-12.79 + elev * 0.711) ) );
		} else {
			correction = -20.774 / te;
		}
		correction = correction / 3600.0;
	}

	return correction;
}

struct AzEl{
	double Azimuth;
	double Elevation;
};

AzEl calcAzEl(T, localtime, latitude, longitude, zone) {

	var eqTime = calcEquationOfTime(T)
	var theta  = calcSunDeclination(T)

	var solarTimeFix = eqTime + 4.0 * longitude - 60.0 * zone
	var earthRadVec = calcSunRadVector(T)
	var trueSolarTime = localtime + solarTimeFix
	while (trueSolarTime > 1440) {
		trueSolarTime -= 1440
	}
	var hourAngle = trueSolarTime / 4.0 - 180.0;
	if (hourAngle < -180) {
		hourAngle += 360.0
	}
	var haRad = degToRad(hourAngle)
	var csz = Math.sin(degToRad(latitude)) * Math.sin(degToRad(theta)) + Math.cos(degToRad(latitude)) * Math.cos(degToRad(theta)) * Math.cos(haRad)
	if (csz > 1.0) {
		csz = 1.0
	} else if (csz < -1.0) {
		csz = -1.0
	}
	var zenith = radToDeg(Math.acos(csz))
	var azDenom = ( Math.cos(degToRad(latitude)) * Math.sin(degToRad(zenith)) )
	if (Math.abs(azDenom) > 0.001) {
		var azRad = (( Math.sin(degToRad(latitude)) * Math.cos(degToRad(zenith)) ) - Math.sin(degToRad(theta))) / azDenom
		if (Math.abs(azRad) > 1.0) {
			if (azRad < 0) {
				azRad = -1.0
			} else {
				azRad = 1.0
			}
		}
		var azimuth = 180.0 - radToDeg(Math.acos(azRad))
		if (hourAngle > 0.0) {
			azimuth = -azimuth
		}
	} else {
		if (latitude > 0.0) {
			var azimuth = 180.0
		} else {
			var azimuth = 0.0
		}
	}
	if (azimuth < 0.0) {
		azimuth += 360.0
	}
	var exoatmElevation = 90.0 - zenith

	// Atmospheric Refraction correction
	var refractionCorrection = calcRefraction(exoatmElevation)

	var solarZen = zenith - refractionCorrection;
	var elevation = 90.0 - solarZen

	return AzEl{azimuth, elevation};
}

function calcSolNoon(jd, longitude, timezone) {
	var tnoon = calcTimeJulianCent(jd - longitude/360.0)
	var eqTime = calcEquationOfTime(tnoon)
	var solNoonOffset = 720.0 - (longitude * 4) - eqTime // in minutes
	var newt = calcTimeJulianCent(jd + solNoonOffset/1440.0)
	eqTime = calcEquationOfTime(newt)
	var solNoonLocal = 720 - (longitude * 4) - eqTime + (timezone*60.0)// in minutes
	while (solNoonLocal < 0.0) {
		solNoonLocal += 1440.0;
	}
	while (solNoonLocal >= 1440.0) {
		solNoonLocal -= 1440.0;
	}

	return solNoonLocal
}



function calcSunriseSetUTC(rise, JD, latitude, longitude) {
	var t = calcTimeJulianCent(JD);
	var eqTime = calcEquationOfTime(t);
	var solarDec = calcSunDeclination(t);
	var hourAngle = calcHourAngleSunrise(latitude, solarDec);
	if (!rise) hourAngle = -hourAngle;
	var delta = longitude + radToDeg(hourAngle);
	var timeUTC = 720 - (4.0 * delta) - eqTime;	// in minutes

	return timeUTC
}

// rise = 1 for sunrise, 0 for sunset
function calcSunriseSet(rise, JD, latitude, longitude, timezone) {

	var timeUTC = calcSunriseSetUTC(rise, JD, latitude, longitude);
	var newTimeUTC = calcSunriseSetUTC(rise, JD + timeUTC/1440.0, latitude, longitude);
	if (isNumber(newTimeUTC)) {
		var timeLocal = newTimeUTC + (timezone * 60.0)
		var riseT = calcTimeJulianCent(JD + newTimeUTC/1440.0)
		var riseAzEl = calcAzEl(riseT, timeLocal, latitude, longitude, timezone)
		var azimuth = riseAzEl.azimuth
		var jday = JD
		if ( (timeLocal < 0.0) || (timeLocal >= 1440.0) ) {
			var increment = ((timeLocal < 0) ? 1 : -1)
			while ((timeLocal < 0.0)||(timeLocal >= 1440.0)) {
				timeLocal += increment * 1440.0
				jday -= increment
			}
		}

	} else { // no sunrise/set found

		var azimuth = -1.0
		var timeLocal = 0.0
		var doy = calcDoyFromJD(JD)
		if ( ((latitude > 66.4) && (doy > 79) && (doy < 267)) ||
		     ((latitude < -66.4) && ((doy < 83) || (doy > 263))) ) {
			//previous sunrise/next sunset
			jday = calcJDofNextPrevRiseSet(!rise, rise, JD, latitude, longitude, timezone)
		} else {   //previous sunset/next sunrise
			jday = calcJDofNextPrevRiseSet(rise, rise, JD, latitude, longitude, timezone)
		}
	}

	return {"jday": jday, "timelocal": timeLocal, "azimuth": azimuth}
}

function calcJDofNextPrevRiseSet(next, rise, JD, latitude, longitude, tz) {

	var julianday = JD;
	var increment = ((next) ? 1.0 : -1.0);
	var time = calcSunriseSetUTC(rise, julianday, latitude, longitude);

	while(!isNumber(time)) {
		julianday += increment;
		time = calcSunriseSetUTC(rise, julianday, latitude, longitude);
	}
	var timeLocal = time + tz * 60.0
	while ((timeLocal < 0.0) || (timeLocal >= 1440.0)) {
		var incr = ((timeLocal < 0) ? 1 : -1)
		timeLocal += (incr * 1440.0)
		julianday -= incr
	}

	return julianday;
}

/*************************************************************/
/* end calculation functions */
/*************************************************************/

monthList = [
	{name: "January",   numdays: 31, abbr: "Jan"},
	{name: "February",  numdays: 28, abbr: "Feb"},
	{name: "March",     numdays: 31, abbr: "Mar"},
	{name: "April",     numdays: 30, abbr: "Apr"},
	{name: "May",       numdays: 31, abbr: "May"},
	{name: "June",      numdays: 30, abbr: "Jun"},
	{name: "July",      numdays: 31, abbr: "Jul"},
	{name: "August",    numdays: 31, abbr: "Aug"},
	{name: "September", numdays: 30, abbr: "Sep"},
	{name: "October",   numdays: 31, abbr: "Oct"},
	{name: "November",  numdays: 30, abbr: "Nov"},
	{name: "December",  numdays: 31, abbr: "Dec"},
];


//--------------------------------------------------------------
// returns a string in the form DDMMMYYYY[ next] to display prev/next rise/set
// flag=2 for DD MMM, 3 for DD MM YYYY, 4 for DDMMYYYY next/prev
function dayString(jd, next, flag) {

	if ( (jd < 900000) || (jd > 2817000) ) {
		return  "error"
	}

	var date = calcDateFromJD(jd)

	if (flag == 2)
		var output = zeroPad(date.day,2) + " " + monthList[date.month-1].abbr;
	if (flag == 3)
		var output = zeroPad(date.day,2) + monthList[date.month-1].abbr + date.year.toString();
	if (flag == 4)
		var output = zeroPad(date.day,2) + monthList[date.month-1].abbr + date.year.toString() + ((next) ? " next" : " prev");

	return output;
}

//--------------------------------------------------------------
function timeDateString(JD, minutes) {
	return timeString(minutes, 2) + " " + dayString(JD, 0, 2);
}

//--------------------------------------------------------------
// timeString returns a zero-padded string (HH:MM:SS) given time in minutes
// flag=2 for HH:MM, 3 for HH:MM:SS
function timeString(minutes, flag) {
	if ( (minutes >= 0) && (minutes < 1440) ) {
		var floatHour = minutes / 60.0;
		var hour = Math.floor(floatHour);
		var floatMinute = 60.0 * (floatHour - Math.floor(floatHour));
		var minute = Math.floor(floatMinute);
		var floatSec = 60.0 * (floatMinute - Math.floor(floatMinute));
		var second = Math.floor(floatSec + 0.5);
		if (second > 59) {
			second = 0
			minute += 1
		}
		if ((flag == 2) && (second >= 30)) minute++;
		if (minute > 59) {
			minute = 0
			hour += 1
		}
		var output = zeroPad(hour,2) + ":" + zeroPad(minute,2);
		if (flag > 2) output = output + ":" + zeroPad(second,2);
	} else {
		var output = "error"
	}

	return output;
}


//--------------------------------------------------------------
// zero pad a string 'n' with 'digits' number of zeros
function zeroPad(n, digits) {

	n = n.toString();
	while (n.length < digits) {
		n = '0' + n;
	}
	return n;
}

//--------------------------------------------------------------
// Read a form input box and do some validation on the result
function readTextBox(inputId, numchars, intgr, pad, min, max, def) {

	var number = document.getElementById(inputId).value.substring(0,numchars)
	if (intgr) {
		number = Math.floor(parseFloat(number))
	} else {  // float
		number = parseFloat(number)
	}

	if (number < min) {
		number = min
	} else if (number > max) {
		number = max
	} else if (number.toString() == "NaN") {
		number = def
	}

	if ((pad) && (intgr)) {
		document.getElementById(inputId).value = zeroPad(number,2)
	} else {
		document.getElementById(inputId).value = number
	}

	return number
}


//--------------------------------------------------------------
// get, validate, reset if necessary, the date and time input boxes
function getDatevals() {

	var docmonth = $('#mosbox').prop('selectedIndex') + 1
	var docday = $('#daybox').prop('selectedIndex') + 1
	var docyear = readTextBox("yearbox", 5, 1, 0, -2000, 3000, 2009)
	var dochr = readTextBox("hrbox", 2, 1, 1, 0, 23, 12)
	var docmn = readTextBox("mnbox", 2, 1, 1, 0, 59, 0)
	var docsc = readTextBox("scbox", 2, 1, 1, 0, 59, 0)
	var docpm = $('#pmbox').prop('checked')

	if ( (isLeapYear(docyear)) && (docmonth == 2) ) {
		if (docday > 29) {
			docday = 29
			$('#daybox').prop('selectedIndex', docday - 1)
		}
	} else {
		if (docday > monthList[docmonth-1].numdays) {
			docday = monthList[docmonth-1].numdays
			$('#daybox').prop('selectedIndex', docday - 1)
		}
	}

	if ( (docpm) && (dochr < 12) ) {
		dochr += 12
	}

	return {"year": docyear, "month": docmonth, "day": docday, "hour": dochr, "minute": docmn, "second": docsc}
}

//--------------------------------------------------------------
function getDateString(date) {

        var s = date.year
		+ '-'
		+ zeroPad(date.month,2)
		+ '-'
		+ zeroPad(date.day,2)
		+ 'T'
		+ zeroPad(date.hour,2)
		+ ':'
		+ zeroPad(date.minute,2)
		+ ':'
		+ zeroPad(date.second,2)

	return s
}


//--------------------------------------------------------------
// Get the input data from the form (date, time, location, time zone)
function get_input_data(adjusttz) {

	var date = getDatevals()
	var mins = date.hour*60 + date.minute + date.second/60.0
	var lat = parseFloat($('#latbox').val())
	var lng = parseFloat($('#lngbox').val())
        var tzname = $('#tz').val();

        // get utc offset for selected timezone and date
        if (adjusttz == false) {
		var utcoffset = $('#zonebox').val()

	} else {
		// make sure utc offset is set correctly
		// (may have changed entered day value if it was out of range)
		var datestr = getDateString(date)
		var utcoffset = moment(datestr).tz(tzname).format('Z');
		$('#zonebox').val(utcoffset)
	}

	var a = utcoffset.split(":")
	var tz = parseFloat(a[0]) + parseFloat(a[1])/60.0

	var data = {
		"year": date.year,
		"month": date.month,
		"day": date.day,
		"hour": date.hour,
		"minute": date.minute,
		"second": date.second,
		"time_local": mins,
		"utc_offset": utcoffset,
		"lat": lat,
		"lon": lng,
		"tz": tz,
	}

	return data
}

//--------------------------------------------------------------
// Do the calculations and update the result text boxes
void calculate(bool adjusttz, tm tms) {
	var data = get_input_data(adjusttz) //date
	var jday = getJD(data.year, data.month, data.day)
	var total = jday + data.time_local/1440.0 - data.tz/24.0
	var T = calcTimeJulianCent(total)
	var azel = calcAzEl(T, data.time_local, data.lat, data.lon, data.tz)
	var solnoon = calcSolNoon(jday, data.lon, data.tz)
	var rise = calcSunriseSet(1, jday, data.lat, data.lon, data.tz)
	var set  = calcSunriseSet(0, jday, data.lat, data.lon, data.tz)

	var eqTime = calcEquationOfTime(T)
	var theta  = calcSunDeclination(T)
}
